import { Component, OnDestroy } from '@angular/core';
import { MatDialog } from '@angular/material/dialog';
import { UserService } from '../services/user.service';
import pkg from 'app/package.json';
import { FireStoreService } from '../services/fire-store.service';
import { Subscription } from 'rxjs';
import { Router } from '@angular/router';
import { Lobby } from '../common/firestore/lobby';
import { RunMode } from '../common/run/run-mode';
import { InputDialogComponent } from '../dialogs/input-dialog/input-dialog.component';
import { ConfirmComponent } from '../dialogs/confirm/confirm.component';
import { MatTableDataSource } from '@angular/material/table';
import { Category } from '../common/run/category';

@Component({
  selector: 'app-lobby',
  templateUrl: './lobby.component.html',
  styleUrls: ['./lobby.component.scss']
})
export class LobbyComponent implements OnDestroy {

  runMode = RunMode;
  categoryOptions: Category[] = Category.GetGategories();

  buildVersion: string = pkg.version;
  newLobbies: Lobby[] = [];
  inProgressLobbies: Lobby[] = [];
  loaded: boolean = false;
  inMaintance: boolean;

  selectedLobby: Lobby | null = null;
  hideViewer: boolean = true;
  
  dataSource: MatTableDataSource<Lobby> = new MatTableDataSource();
  dataSourceInProgress: MatTableDataSource<Lobby> = new MatTableDataSource();
  columns: string[] = ["name", "mode", "category", "teams", "players"];

  lobbiesSubscription: Subscription;
  userSubscription: Subscription;

  constructor(public _user: UserService, private _firestore: FireStoreService, private router: Router, private dialog: MatDialog) {

    if (_user.clientUpdate && _user.clientUpdate.available) {
      const dialogSubscription = this.dialog.open(ConfirmComponent, { data: { message: _user.clientUpdate.message, yesNo: false } }).afterClosed().subscribe(() => {
        dialogSubscription.unsubscribe();
      });
    }
    
    setTimeout(()=> {
      this.lobbiesSubscription = this._firestore.getOpenLobbies().subscribe((lobbies) => {
        const expireDate = new Date();
        expireDate.setHours(expireDate.getHours() - 4);
        //remove old lobbies
        lobbies.filter(x => new Date(x.creationDate) < expireDate).forEach(lobby => {
          _firestore.deleteLobby(lobby.id);
        });
        
        lobbies = lobbies.filter(x => new Date(x.creationDate) >= expireDate);
        
        //(The question marks in user for filtering here is only for backwards compability)
        lobbies.filter(x => x.users.some(user => user?.user?.id === _user.user.id) || x.host?.user?.id === _user.user.id).forEach(lobby => {
          lobby = Object.assign(new Lobby(lobby.runData, lobby.creatorId, lobby.allowLateSpectate, lobby.password, lobby.id), lobby);
          if (lobby.host?.user.id === _user.user.id)
            lobby.host = null;
          
          lobby.removeUser(_user.user.id);
          lobby.visible = false;
          _firestore.updateLobby(lobby);
        });
  
        const version = this.buildVersion.slice(0, -2);
        this.newLobbies = lobbies.filter(x => !x.inProgress).sort((x, y) => new Date(y.creationDate).valueOf() - new Date(x.creationDate).valueOf());
        this.dataSource = new MatTableDataSource(this.newLobbies);
        this.inProgressLobbies = lobbies.filter(x => x.inProgress).sort((x, y) => new Date(y.creationDate).valueOf() - new Date(x.creationDate).valueOf());
        this.dataSourceInProgress = new MatTableDataSource(this.inProgressLobbies);
        this.selectedLobby = this.newLobbies[0];
        this.loaded = true;
        this._user.clientInMaintenanceMode = false;
      }, error => {
        if (error.message === "Missing or insufficient permissions.")
          this._user.clientInMaintenanceMode = true;
      });
    }, 500); //quick pause to give the db chance to dehost properly when exiting !TODO: fix by awaiting in runhandler destory

    
    this.userSubscription = this._user.userSetupSubject.subscribe(user => {
      if (!user) return;

      //this should technically be ran on user setup subject
      if (_user.user.saveRecordingsLocally === undefined) {
        const dialogSubscription = this.dialog.open(ConfirmComponent, { data: { message: "Do you want to save recordings of runs locally?", yesNo: true } }).afterClosed().subscribe(confirmed => {
          dialogSubscription.unsubscribe();
          this._user.user.saveRecordingsLocally = confirmed === undefined ? false : confirmed;
          _user.writeSettings();
        });
      }
    });
  }

  routeToRun(lobby: Lobby) {
    if (!lobby.available) return;
    
    if (lobby.password) {
      const dialogRef = this.dialog.open(InputDialogComponent, { data: { passwordCheck: true, password: lobby.password, precursorTitle: "Password", title: "Lobby password:", confirmText: "Join" } });
      const dialogSubscription = dialogRef.afterClosed().subscribe((successful: boolean | null) => {
        dialogSubscription.unsubscribe();
        if (successful === undefined)
          return;
        if (!successful)
          this._user.sendNotification("Wrong password!");
        if (successful)
        this.router.navigate(lobby.runData.mode !== this.runMode.Casual ? ['/run'] : ['/run-casual'], { queryParams: { id: lobby.id } });
      });
    }
    else
      this.router.navigate(lobby.runData.mode !== this.runMode.Casual ? ['/run'] : ['/run-casual'], { queryParams: { id: lobby.id } });
  }
  


  selectLobby(lobby: Lobby) {
    this.selectedLobby = lobby;
    this.hideViewer = false;
  }

  hideLobbyViewer() {
    this.hideViewer = true;
  }

  toggleSetting(): void {
    this._user.viewSettings = !this._user.viewSettings;
  }

  deleteLobby(event: Event, lobby: Lobby) {
    event.stopPropagation();
    const dialogSubscription = this.dialog.open(ConfirmComponent, { data: { message: "Delete " + lobby.runData.name + "?" } }).afterClosed().subscribe(confirmed => {
      dialogSubscription.unsubscribe();
      if (confirmed)
        this._firestore.deleteLobby(lobby.id);
    });
  }

  ngOnDestroy() {
    if (this.lobbiesSubscription) this.lobbiesSubscription.unsubscribe();
    if (this.userSubscription) this.userSubscription.unsubscribe();
  }

}
